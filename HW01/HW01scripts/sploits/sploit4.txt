
In target4, snprintf (snprintf(buf, sizeof buf, arg)) has been used which is secure against buffer overflow, so any approach to hack by using buffer over flow will not work. 
This made me think of using format string vulnerability as mentioned in the lecture. We can control the format string so we can easily read stack until the return address in stack and then overwrite it by using %n .  If we pass enough %08x as parameters in format string we can print the stack and we can see the value of eip before the function foo returns call. I tried with 1 , 2 %08x and the %n was writing at non writable locations of the stack leading to crash, thus i tried 3 and program didn't crash anymore , I was able to write in buffer !! Now i just need to find the location of return statement and overwrite by the address of 1 byte after eip(start of buffer). Inside the buffer we can pad some NOPs and then put the shellcode. 
Next problem is to print exact number of characters which %n counts for writing to memeory. For doing this %u is better to be used. By using %u%u0wu , atleast w+2 0's can be printed and %n would then write 10 to stack. So now, to make n write 0xbbfb5c ( where buf is located  and we want eip to go to) , we need as many 0's. On trial this fails because too many characters. So then I tried writing the first three bytes of address in eip. This means  0xbffffbâ€“ which is 12582907 in decimal. Writing this worked. 
